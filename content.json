{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"VUE note about responsive","text":"从2019年2月开始进入vue开发，几个月下来踩了不少坑 这里记录一下需要注意的点，首先是vue的数据响应式 响应式Vue 最独特的特性之一，是其非侵入性的响应式系统 使用vue最方便的地方在于不关心数据展示只关注数据本身，而实现响应式的更本是ES5中的 Object.defineProperty 转换所有属性为 getter/setter 这也是vue 不支持IE8 及以下浏览器的原因 Vue 无法检测到对象属性的添加或删除。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化，所以属性必须在 data 对象上存在才能让 Vue 将它转换为响应式的，对于已经创建的实例，Vue 不允许动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, propertyName, value) 方法向嵌套对象添加响应式属性 比如 123Vue.set(vm.someObject, 'b', 2)//orthis.$set(this.someObject,'b',2) 有时你可能需要为已有对象赋值多个新属性，比如使用 Object.assign() 或 _.extend()。但是，这样添加到对象上的新属性不会触发更新。在这种情况下，你应该用原对象与要混合进去的对象的属性一起创建一个新的对象。 1234// 代替 `Object.assign(this.someObject, { a: 1, b: 2 })`this.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })// 还可以用解构this.someObject = { ...{ a: 1, b: 2 }), ...this.someObject } 数组触发更新检测也差不多 1234567this.someArry[1] = 'x' // 不是响应性的this.someArry.length = 2 // 不是响应性的//解决方法this.$set(vm.items, indexOfItem, newValue)this.someArry.splice(newLength)this.someArry=[...newArry] 异步更新队列 Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部对异步队列尝试使用原生的 Promise.then、MutationObserver 和 setImmediate，如果执行环境不支持，则会采用 setTimeout(fn, 0) 代替。当你设置 vm.someData = ‘new value’，该组件不会立即重新渲染。当刷新队列时，组件会在下一个事件循环“tick”中更新。多数情况我们不需要关心这个过程，但是如果你想基于更新后的 DOM 状态来做点什么，这就可能会有些棘手。虽然 Vue.js 通常鼓励开发人员使用“数据驱动”的方式思考，避免直接接触 DOM，但是有时我们必须要这么做。为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用 1&lt;div id=\"example\"&gt;{{message}}&lt;/div&gt; 123456789var vm = new Vue({ el: '#example', data: { message: '123' } })vm.message = 'new message' // 更改数据 vm.$el.textContent === 'new message' // falseVue.nextTick(function () { vm.$el.textContent === 'new message' // true }) 因为 $nextTick() 返回一个 Promise 对象，所以你可以使用新的 ES2016 async/await 语法完成相同的事情： 12345678methods: { updateMessage: async function () { this.message = '已更新' console.log(this.$el.textContent) // =&gt; '未更新' await this.$nextTick() console.log(this.$el.textContent) // =&gt; '已更新' }}","link":"/2019/06/13/VUE-note/"},{"title":"good for work","text":"工作了几年中途遇到过很多需要使用工具的情况，下面是一些我收集的对我有帮助的小玩意 Everything很多时候在你明明知道电脑的盘里有一个文件 你知道它的名字，但是用文件资源管理器的搜索那个速度非常感人，尤其是你在不确定是哪个盘符的时候，其他工具用的不多，但是Everything这个速度确实不错。 百度网盘:https://pan.baidu.com/s/1qbHS25eve8M3l0QgwSXc3g提取码：o526 拖把更名器使用电脑工作中，需要对一些文件，不仅仅是图片，更具一个规则重命名，但是一个个改又麻烦，这个就很有用了，它可以自定义规则，改拓展名替换原来名字中的字符，改标签… 百度网盘:https://pan.baidu.com/s/1nduQ2fHLobFUXG7xJ8HclQ提取码：kb80 FTPserver一个快捷搭建FTP服务器的工具 比在iis里面快 百度网盘:https://pan.baidu.com/s/1LzM20AB0bQ90JWCDATborw提取码：9lnb SETUNA一个截图工具，与其他截图不同的是它截出的图可以多张保持在屏幕上，在做一些对比和需要一个便签效果时 很实用，作为一个前端开发 很实用的一点就比如你需要原型图 设计图 还有代码块同时展示做对比，这种时候就很便利，不需要不停地切换应用，尤其是在你没有多块屏幕的时候. 百度网盘:https://pan.baidu.com/s/1xn_SEhoYX9NNAjZeIupVgg提取码：lwyv TAKECOLOR一个通过鼠标获取颜色代码的工具，在UI出图没有蓝湖这种工具能提供详细注释，只有一张图的话，取颜色就很关键，这个取颜色很出色.. 百度网盘:https://pan.baidu.com/s/1DhtUBagBnMQl_r458Bp22Q提取码：ekua 封面unsplash-logoMarkus Spiske","link":"/2018/03/03/good-for-work/"},{"title":"good web site","text":"上一篇是需要下载的一些工具，下面是一些在线的好用的 工具地址 或者一些不错的网址 logo生成description 当你自己又一个网站的时候， 你会想有一个自己的logo，这个网址能帮没有什么设计天赋的你，你只需提供一个logo的名字，他可以生成很多款式的图，我的logo就这做的 ShowDocdescription 一个非常适合IT团队的在线API文档、技术文档工具 在线的小组的技术分享，踩坑解决办法等 method drawdescription 这个网站可以自定义svg路径 你自己画一个图，它可以生成svg文件（ctrl+s） 或者直接拿到svg代码（ctrl+u） json 数据返回外网接口https://node-hnapi.herokuapp.com/news?page=1 description 这是一个可以返回json数据的地址，你可以改变参数page比如变成2可以在写一个功能时模拟数据请求 不用搭建数据请求环境 base64图片转换description 在公司做为一个前端开发，当你需要维护一些老的页面，并没有用什么打包工具，不能自动处理与css路径的更改时内部带的图片路径，你还要把这个东西给一个并不熟悉css里面图片路径引用的人他去替换到加了业务逻辑的代码中的时候，很容易图片路径就不对了展示不出来。而如果你把图片用base64写到css里面就不用管静态图片到底该放在哪，就很舒服，所以找了一个在线转图片的网址 获取随机图片（自定义宽高）description 在写一些demo时，用到图片总是要自己找一些来放在项目里面，但是这个网址就不需要，大小写也自定义就结尾的数字带代表宽高，还支持用背景图的方式写比如：同理src上一样 background:url(http://source.unsplash.com/random/150x150) 美图秀秀批处理在线版description 美图秀秀批处理在线版提供 图片批量剪裁 重命名 加水印 这些功能 我主要用在这种博客需要的图片你在选完之后大小总是不一样 命名也不规律 可以用这个批量处理一下 封面unsplash-logoVictoria Tronina","link":"/2018/02/13/good-web-site/"},{"title":"img-show","text":"","link":"/2018/04/04/img-show/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new postCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 封面unsplash-logoMatt Hardy","link":"/2018/01/24/hello-world/"},{"title":"gitalk set","text":"就在昨天进入Valine 评论后台发现没有自己域名的调用在10月1号就会停止服务，我也没有那个需求要专门给自己的博客买一个域名，所以换了一个评论插件gitalk 说道为什么需要自动化原因是Gitalk配置完成后，启动hexo，打开文章页面，需要登陆github，完成初始化后才能使用，并且是每一篇没有初始化的文章都需要，虽然你如果登录了点开文章就会自动创建，但是每一篇新文章都需要点进去，博客少还好但是多了就不好搞了，所以这个自动初始化很有必要，gitakl怎么加入博客这个官网 就有例子，照着做就行了，网上也很多比如这个 ，自动初始化的我找了下都是什么py或者其他自动化语言写的，我这用的node搞了一个 gitalk setting实现gitalk 自动为文章生成评论栏第一步 获取github接口的调用权限 创建一个access token，点击链接进入 点击Generate new token 添加所有的repo权限 在repo前面打勾勾 然后点击最下方的Generate token绿色按钮，就可以生成一个新的Token备用 生成sitemap站点地图 站点地图是一种文件，您可以通过该文件列出您网站上的网页，从而将您网站内容的组织架构告知Google和其他搜索引擎。搜索引擎网页抓取工具会读取此文件，以便更加智能地抓取您的网站 安装插件这里我们用这个来获取文章的路径数量信息 在你hexo的根目录，执行下面两个命令来安装针对google和百度的插件 12npm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 在站点根目录下的_config.yml添加如下代码 123456# hexo sitemap网站地图sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 到这一步 执行hexo generate的时候，在博客根目录下的public文件夹下面，就会生成sitemap.xml和baidusitemap.xml More info: Server 脚本文件编写 安装依赖包 在你hexo的根目录，执行下面的命令 分别是一些 请求插件， 1234npm install request --savenpm install xml-parser --savenpm install yamljs --savenpm install cheerio --save 创建脚本文件 在站点根目录下创建comment.js文件，将下面的代码粘贴进文件中，然后修改config中的配置项，其中token就是上一步中获取的值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 初始化gitakl 评论 const request = require(\"request\");const fs = require(\"fs\");const path = require(\"path\");const url = require(\"url\");const xmlParser = require(\"xml-parser\");const YAML = require(\"yamljs\");const cheerio = require(\"cheerio\");//服务端jqconst crypto = require('crypto');//md5// 根据自己的情况进行配置const config = { username: \"YuThree\", // GitHub 用户名 token: \"xxxxxxxxxxxxxxxxxxxxxxxx\", // GitHub Token repo: \"yuthreeComment\", // 存放 issues的git仓库 自己创一个专门存评论的仓库 // sitemap.xml的路径，commit.js放置在根目录下，无需修改，其他情况自行处理 sitemapUrl: path.resolve(__dirname, \"./public/sitemap.xml\"), kind: \"Gitalk\", };let issuesUrl = `https://api.github.com/repos/${config.username}/${config.repo}/issues?access_token=${config.token}`;let requestGetOpt = { url: `${issuesUrl}&amp;page=1&amp;per_page=1000`, json: true, headers: { \"user-agent\": \"YuThree\" }};let requestPostOpt = { ...requestGetOpt, url:issuesUrl, method: \"POST\", form: \"\"};console.log(\"开始初始化评论...\");(async function() { console.log(\"开始检索链接，请稍等...\"); try { let urls = sitemapXmlReader(config.sitemapUrl); console.log(`共检索到${urls.length}个链接`); console.log(urls) console.log(\"开始获取已经初始化的issues:\"); console.log('请求连接为---'+issuesUrl) let issues = await send(requestGetOpt); console.log(`已经存在${issues.length}个issues`); let notinitissuelinks = urls.filter((link) =&gt; { return !issues.find((item) =&gt; { link = removeProtocol(link); return item.body.includes(link); }); }); if (notinitissuelinks.length &gt; 0) { console.log(`本次有${notinitissuelinks.length}个链接需要初始化issue：`); console.log(notinitissuelinks); console.log(\"开始提交初始化请求, 大约需要2秒...\"); setTimeout(async ()=&gt;{ let initRet = await notinitissuelinks.map(async (item) =&gt; { let html = await send({ ...requestGetOpt, url: item }); let $ = cheerio.load(html) let title = $(\"title\").first().text();//issue的标题 可以改 let pathLabel = md5Sign(url.parse(item).path);//这里的md5与生成gitalk的需要相同 是issue的id let body = `地址：${item}&lt;br&gt;&lt;br&gt;简介：${$('#more').prev().text()}`;//可以自己编写想要的body issue的正文 地址不能改，前面的去重判断用到这个 let form = JSON.stringify({ body, labels: [config.kind, pathLabel], title, client_id:config.client_id, client_secret:config.client_secret}); return send({ ...requestPostOpt, form }); }); console.log(`已完成${initRet.length}个！`); console.log(\"可以愉快的发表评论了！\"); },2000); } else { console.log(\"本次发布无新增页面，无需初始化issue!!\"); } } catch (e) { console.log(`初始化issue出错，错误如下：`); console.log(e); } finally { }})();function sitemapXmlReader(file) { let data = fs.readFileSync(file, \"utf8\"); let sitemap = xmlParser(data); return sitemap.root.children.map(function (url) { let loc = url.children.filter(function (item) { return item.name === \"loc\"; })[0]; return loc.content; });}function removeProtocol(url) { return url.substr(url.indexOf(\":\"));}function send(options) { return new Promise(function (resolve, reject) { request(options, function (error, response, body) { if (!error) { resolve(body); } else { reject(error); } }); });}function md5Sign(data) { // 加入字符编码 var md5 = crypto.createHash('md5').update(data).digest('hex'); return md5;} 执行脚本 需要注意的是第二步中的sitemap插件会生成的sitemap.xml会包含全部的界面，包括标签页、关于页等，执行上面的代码也会对这些页面生成评论框(也就是一条issue) 完成上述操作后，执行下面的命令，就可以部署站点，并初始化所有的评论了。1234hexo cleanhexo generatehexo deploynode ./comment.js 也可以通过在站点根目录的package.json文件中，新建npm脚本，一个命令搞定清除缓存、生成静态文件、提交git并生成issue的所有操作。1234\"scripts\": { \"start\": \"hexo clean &amp;&amp; hexo s\", \"build\": \"hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy &amp;&amp; node ./comment.js\"} 之后完成文章编写，或者其他的更新操作后，直接执行build即可1npm run build 后记 最开始的gittoken 获取后复制出来 他会带一个空格，也可能是我的复制姿势不对，导致开始的连接返回值不对，是个小坑 Gitalk在页面登陆初始化的时候，默认生成的issue label是链接的path，生成的时候用的path为了满足issue的label不超过50个字符所以都用md5加密了一下，这里就要注意里面的path与这里的path必须一致 参考Gitment/Gitalk自动初始化 自动初始化 Gitalk 和 Gitment 评论 nodejs版本的Gitalk/Gitment评论自动初始化 封面unsplash-logoMatt Hardy","link":"/2019/08/06/gitalk-set/"},{"title":"vue note about watch","text":"vue note 续篇 watch watchVue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的 1234567watch: { // 如果 data的`question` 发生改变，这个函数就会运行 question: function (newQuestion, oldQuestion) { this.answer = 'Waiting for you to stop typing...' this.dosomthing() } }, 实例方法123456789vm.$watch( expOrFn, callback, [options] )参数：{String | Function} expOrFn{Function | Object} callback{Object} [options] {Boolean} deep {Boolean} immediate返回值：{Function} unwatch 注意：在变异 (不是替换) 对象或数组时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变异之前值的副本。 实例 123456789101112131415161718192021// 键路径vm.$watch('a.b.c', function (newVal, oldVal) { // 做点什么})// 函数vm.$watch( function () { // 表达式 `this.a + this.b` 每次得出一个不同的结果时 // 处理函数都会被调用。 // 这就像监听一个未被定义的计算属性 return this.a + this.b }, function (newVal, oldVal) { // 做点什么 })//vm.$watch 返回一个取消观察函数，用来停止触发回调：var unwatch = vm.$watch('a', cb)// 之后取消观察unwatch() 选项：deep为了发现对象内部值的变化，可以在选项参数中指定 deep: true 。注意监听数组的变动不需要这么做。 12345vm.$watch('someObject', callback, { deep: true})vm.someObject.nestedValue = 123// callback is fired 选项：immediate在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调： 1234vm.$watch('a', callback, { immediate: true})// 立即以 `a` 的当前值触发回调 computed对于任何复杂逻辑，你都应当使用计算属性。 computed和方法差不多调用也只有一个括号差别，但是计算属性是基于它们的响应式依赖进行缓存的 只在相关响应式依赖发生改变时它们才会重新求值，相比之下，每当触发重新渲染时，调用方法将总会再次执行函数,如果你有一个for循环计算，调用次数较多就可以考虑用计算属性 封面unsplash-logoMatt Hardy","link":"/2019/06/15/vue-note-about-computed/"}],"tags":[{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"note","slug":"note","link":"/tags/note/"},{"name":"链接","slug":"链接","link":"/tags/链接/"},{"name":"百度网盘","slug":"百度网盘","link":"/tags/百度网盘/"},{"name":"网站收藏","slug":"网站收藏","link":"/tags/网站收藏/"},{"name":"壁纸","slug":"壁纸","link":"/tags/壁纸/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"gitakl","slug":"gitakl","link":"/tags/gitakl/"}],"categories":[{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"工具v","slug":"工具v","link":"/categories/工具v/"},{"name":"工具","slug":"工具","link":"/categories/工具/"},{"name":"img","slug":"img","link":"/categories/img/"},{"name":"hello-word","slug":"hello-word","link":"/categories/hello-word/"},{"name":"下载链接","slug":"工具v/下载链接","link":"/categories/工具v/下载链接/"},{"name":"在线链接","slug":"工具/在线链接","link":"/categories/工具/在线链接/"},{"name":"setcomment-gitalk","slug":"setcomment-gitalk","link":"/categories/setcomment-gitalk/"}]}